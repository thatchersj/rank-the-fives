<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Eton Fives Rankings</title>


  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 24px; }
    header { display:flex; gap:16px; align-items:baseline; justify-content:space-between; flex-wrap:wrap; }
    h1 { margin:0; font-size: 24px; }
    .meta { color:#555; font-size: 14px; min-height: 20px; }
    .actions { display:flex; gap:12px; flex-wrap:wrap; }
    .actions a, .actions button {
      appearance:none; border:1px solid #ccc; border-radius:10px; padding:10px 12px;
      background:white; cursor:pointer; text-decoration:none; color:#111; font-size:14px;
    }
    .actions a:hover, .actions button:hover { background:#f6f6f6; }
    .note { margin: 12px 0 14px; color:#666; font-size: 14px; line-height:1.4; }
    .small { font-size: 12px; color:#666; margin-top:6px; }
    .controls { display:flex; gap:12px; flex-wrap:wrap; align-items:center; margin: 0 0 12px; }
    .controls input, .controls select {
      appearance:none; border:1px solid #ccc; border-radius:10px; padding:10px 12px;
      background:white; font-size:14px; min-width: 220px;
    }

    .table-wrap{
      border:1px solid #ddd; border-radius:14px; overflow:auto;
      max-height: calc(100vh - 260px);
      box-shadow: 0 1px 2px rgba(0,0,0,0.04);
      -webkit-overflow-scrolling: touch;
    }

    /* Full-screen table mode (mobile landscape helper) */
    body.fullscreen-mode{ margin:0; }
    body.fullscreen-mode > header,
    body.fullscreen-mode > .note,
    body.fullscreen-mode > .controls{ display:none; }
    body.fullscreen-mode .table-wrap{
      position: fixed; inset: 0;
      max-height: 100vh;
      border-radius: 0;
      border: none;
      box-shadow: none;
      background: white;
    }
    body.fullscreen-mode .modal{ max-height: 95vh; }

    table { border-collapse: separate; border-spacing: 0; }
    #rankings{ width: max-content; min-width:100%; background:white; }
    #rankings thead th{
      background:#fafafa;
      border-bottom:1px solid #ddd;
      font-weight:600;
      white-space: nowrap;
      padding: 6px 10px;
      position: sticky; top: 0; z-index: 5;
      cursor: default;
      user-select: none;
      touch-action: manipulation;
    }
    #rankings thead th.sortable { cursor: pointer; }
    #rankings thead th.tournament { cursor: pointer; }
    #rankings td{
      padding: 6px 10px;
      border-right:1px solid #eee;
      border-bottom:1px solid #eee;
      white-space: nowrap;
      background:white;
      text-align: center;
    }
    #rankings tbody tr:nth-child(even) td{ background:#fcfcfc; }

    /* Sticky first 4 columns (Rank, Elo, Initial, Surname) */
    #rankings th:nth-child(1), #rankings td:nth-child(1){
      position: sticky; left: 0; z-index: 6; min-width:60px; max-width:60px;
      border-right:1px solid #ddd;
      font-variant-numeric: tabular-nums;
      background: #fff;
}
    #rankings th:nth-child(2), #rankings td:nth-child(2){
      position: sticky; left: 60px; z-index: 6; min-width:80px; max-width:80px;
      border-right:1px solid #ddd;
      background: #fff;
font-variant-numeric: tabular-nums;
    }
    #rankings th:nth-child(3), #rankings td:nth-child(3){
      position: sticky; left: 140px; z-index: 6; min-width:70px; max-width:70px;
      border-right:1px solid #ddd;
      background: #fff;
font-variant-numeric: tabular-nums;
    }
    #rankings th:nth-child(4), #rankings td:nth-child(4){
      position: sticky; left: 210px; z-index: 6; min-width:190px; max-width:190px;
      border-right:1px solid #ddd;
      font-weight:600;
      background: #fff;
}

/* Colour coding (works on mob

    /* Sticky column layering & row striping fixes (mobile / horizontal scroll) */
    #rankings thead th { position: sticky; top: 0; z-index: 20; background: #f5f5f5; }
    #rankings thead th:nth-child(-n+4){ z-index: 30; } /* top-left corner cells above everything */
    #rankings tbody td:nth-child(-n+4){ background: #fff; }
    #rankings tbody tr:nth-child(even) td:nth-child(-n+4){ background:#fcfcfc; }
    /* subtle separation so overlapping is visually clean */
    #rankings th:nth-child(-n+4), #rankings td:nth-child(-n+4){ box-shadow: 2px 0 0 rgba(0,0,0,0.06); }


/* Colour coding (works on mobile because it's inline classes on TD) */
    .res-W{ background:#c6efce !important; color:#006100 !important; }   /* Winner */
    .res-F{ background:#d9e1f2 !important; color:#1f4e79 !important; }   /* Final */
    .res-SF{ background:#fff2cc !important; color:#7f6000 !important; }  /* Semi */
    .res-QF{ background:#fce4d6 !important; color:#7f2a00 !important; }  /* Quarter */
    .res-L16{ background:#fde9d9 !important; color:#7f2a00 !important; } /* Last 16 */
    .res-NQ{ background:#f8cbad !important; color:#833c0c !important; }  /* Non-qual */
    .res-P{ background:#e7e6e6 !important; color:#444 !important; }      /* P */
    .res-UNK{ background:#f2f2f2 !important; color:#555 !important; font-weight:500; }

    th.sorted-asc::after { content:" ‚ñ≤"; font-weight:700; }
    th.sorted-desc::after { content:" ‚ñº"; font-weight:700; }
  
    /* Modal for match details */
    .modal-backdrop{
      position: fixed; inset: 0; background: rgba(0,0,0,0.45);
      display:none; align-items:center; justify-content:center;
      padding: 16px; z-index: 1000;
    }
    .modal{
      width: min(720px, 100%);
      max-height: 80vh;
      overflow:auto;
      background: white;
      border-radius: 16px;
      border: 1px solid #ddd;
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
    }
    .modal header{
      position: sticky; top: 0; z-index: 2;
      background: white;
      padding: 14px 16px;
      border-bottom: 1px solid #eee;
      display:flex; gap:12px; align-items:flex-start; justify-content:space-between;
    }
    .modal h2{ margin:0; font-size: 18px; }
    .modal .close{
      border: 1px solid #ccc; border-radius: 10px; padding: 8px 10px;
      background: white; cursor: pointer; font-size: 14px;
    }
    .modal .content{ padding: 12px 16px 16px; }
    .match-round{ margin: 14px 0 6px; font-weight: 700; }
    .match{
      padding: 10px 12px; border: 1px solid #eee; border-radius: 12px;
      margin: 8px 0; background: #fafafa;
    }
    .match .line{ margin: 4px 0; }
    .pill{
      display:inline-block; padding: 2px 8px; border-radius: 999px;
      border: 1px solid #ddd; background: white; font-size: 12px;
      margin-right: 8px;
    }
    .pill-won{ background:#c6efce; border-color:#9ccc9c; color:#0b5a0b; }
    .pill-lost{ background:#f8cbad; border-color:#f3a981; color:#7f2a00; }

    .elo-pill{ font-variant-numeric: tabular-nums; font-weight:700; margin-right:0; }
    .unc-low{ background:#c6efce; border-color:#9ccc9c; color:#0b5a0b; }
    .unc-med{ background:#fff2cc; border-color:#e6d88a; color:#7f6000; }
    .unc-high{ background:#f8cbad; border-color:#f3a981; color:#7f2a00; }


  
    .eloPanel{ border:1px solid #eee; border-radius:12px; padding:10px 12px; margin: 10px 0 12px; background:#fcfcfc; }
    .eloRow{ display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap; }
    .muted{ color:#666; font-size:12px; }
    .peakBtn{ appearance:none; border:1px solid #ccc; background:#fff; border-radius:999px; padding:6px 10px; font-size:12px; cursor:pointer; }

    /* Help modal tabs */
    .tabs{ display:flex; gap:8px; padding: 0 16px 12px; border-bottom: 1px solid #eee; }
    .tabbtn{
      appearance:none; border:1px solid #ccc; background:#fff;
      border-radius: 999px; padding: 8px 12px; font-size: 13px; cursor:pointer;
    }
    .tabbtn[aria-selected="true"]{ border-color:#111; }
    .tabpanel{ display:none; padding: 12px 16px 16px; }
    .tabpanel.active{ display:block; }
    .tabpanel h3{ margin: 10px 0 6px; font-size: 15px; }
    .tabpanel ul{ margin: 6px 0 10px 18px; }
    .tabpanel code{ background:#f2f2f2; padding:2px 6px; border-radius:6px; }

    .peakBtn:hover{ background:#f6f6f6; }
    .sparkWrap{ margin-top:8px; }
    .sparkSvg{ width: 200px; height: 44px; display:block; }

  </style>
</head>

<body>
  <header>
    <div>
      <div class="row" style="gap:8px; align-items:center;"><h1>Eton Fives Rankings</h1><a href="./debug.html" style="font-size:12px; padding:4px 8px; border:1px solid #ddd; border-radius:999px; text-decoration:none;">üß™ Debug</a></div>
      <div class="meta" id="status">Loading‚Ä¶</div>
    </div>
    <div class="actions">
      <a href="./downloads/rankings_latest.xlsx" download>Download XLSX</a>
      <a href="./downloads/rankings_latest.csv" download>Download CSV</a>
      <a
        href="https://github.com/thatchersj/rank-the-fives/issues/new?template=submit_results.yml&title=New%20tournament%20results&labels=recalculate"
        target="_blank" rel="noopener"
      >Submit new results</a>
    
      <button id="fsBtn" type="button" title="Full screen" aria-label="Toggle full screen">‚õ∂</button>
      <button id="helpBtn" type="button" title="Help" aria-label="Help">?</button>
</div>
  </header>

  <div class="note">
    Tap a column header to sort (mobile supported). Search to find a player.
    <div class="small">Codes: <b>W</b>, <b>F</b>, <b>SF</b>, <b>QF</b>, <b>L16</b>, <b>NQ</b>.</div>
  </div>

  <div class="controls">
    <select id="snapshotSelect" aria-label="As of tournament"></select>
    <input id="searchBox" type="search" placeholder="Search (rank/initial/surname)..." autocomplete="off" />
    <span class="small" id="count"></span>
  </div>

  <div class="table-wrap" id="tableWrap">
    <table id="rankings">
      <thead><tr id="theadRow"></tr></thead>
      <tbody></tbody>
    </table>
  </div>

  <noscript>
    <p><b>This page needs JavaScript enabled</b> to load rankings.</p>
  </noscript>

  <script>
    (function(){
      const TWO_DP_COLS = new Set(["poss","rpa","pc","pc2"]);
function formatMaybe2dp(col, val){
  if (!TWO_DP_COLS.has(String(col).toLowerCase())) return val;
  if (val === null || val === undefined || val === "") return val;
  const num = Number(val);
  if (!Number.isFinite(num)) return val;
  return num.toFixed(2);
}


function displayResultValue(val){
  // Hide 'P' results in the table (treat as blank)
  if (val === "P" || val === "p") return "";
  return val;
}

const statusEl = document.getElementById("status");
      const countEl = document.getElementById("count");
      const searchBox = document.getElementById("searchBox");
      const theadRow = document.getElementById("theadRow");
      const tbody = document.querySelector("#rankings tbody");
      const table = document.getElementById("rankings");

      function normalizeResult(v) {
        const s = (v ?? "").toString().trim().toUpperCase();
        if (!s || s === "P") return "";
        return s.replace(/\s+/g, ""); // "L 16" -> "L16"
      }
      function resultClass(v) {
        const key = normalizeResult(v);
        if (!key) return null;
        if (["W","F","SF","QF","NQ","L16","P"].includes(key)) return "res-" + key;
        return "res-UNK";
      }
            function uncertaintyClass(sigma){
        const s = Number(sigma);
        if (!Number.isFinite(s)) return 'unc-med';
        if (s < 140) return 'unc-low';
        if (s < 250) return 'unc-med';
        return 'unc-high';
      }

function looksLikeResultColumn(colName) {
        // expected like "13 N" / "13N" / "13 K" etc
        return /^\d{2}\s*[NKL]$/i.test(colName.trim().replace(/\s+/g, " "));
      }

      async function loadData() {
        // IMPORTANT: relative to the current page URL (works on GH Pages project sites)
        const latestUrl = new URL("data/rankings_latest.json", window.location.href);
        const resLatest = await fetch(latestUrl.toString(), { cache: "no-store" });
        if (!resLatest.ok) throw new Error(`Failed to load ${latestUrl} (${resLatest.status} ${resLatest.statusText})`);
        const latest = await resLatest.json();
        if (!Array.isArray(latest) || latest.length === 0) throw new Error("No data found in rankings_latest.json");

        // Snapshots (optional)
        let snapshots = null;
        try {
          const snapsUrl = new URL("data/rankings_snapshots.json", window.location.href);
          const resSnaps = await fetch(snapsUrl.toString(), { cache: "no-store" });
          if (resSnaps.ok) snapshots = await resSnaps.json();
        } catch (e) {
          console.warn('No rankings_snapshots.json', e);
        }

        return { latest, snapshots };
      }

      async function loadMatches() {
        const url = new URL("data/matches_latest.json", window.location.href);
        const res = await fetch(url.toString(), { cache: "no-store" });
        if (!res.ok) {
          console.warn("No matches_latest.json", res.status, res.statusText);
          return null;
        }
        return await res.json();
      }

      function render(data) {
        window.__CURRENT_RENDER_DATA = data;
        // Build a stable column order:
        // Rank, Elo, Initial, Surname, POSS/RPA/PC/PC2, EloSkill/EloForm, then tournament columns (most recent first)
        const allCols = Object.keys(data[0] || {});
        const base = ["Rank","Elo","Initial","Surname","POSS","RPA","PC","PC2","EloSkill","EloForm"];
        const baseCols = base.filter(c => allCols.includes(c));

        const tourCols = allCols
          .filter(c => looksLikeResultColumn(c))
          .sort((a,b) => {
            const pa = a.trim().replace(/\s+/g,' ').split(' ');
            const pb = b.trim().replace(/\s+/g,' ').split(' ');
            const ya = parseInt(pa[0],10); const yb = parseInt(pb[0],10);
            const oa = ({N:0,K:1,L:2})[(pa[1]||'').toUpperCase()] ?? 9;
            const ob = ({N:0,K:1,L:2})[(pb[1]||'').toUpperCase()] ?? 9;
            // most recent first
            if (ya !== yb) return yb - ya;
            return ob - oa;
          });

        // Keep EloSigma available for pill colour but don't show as a column
        const cols = [...baseCols, ...tourCols].filter(c => c !== "EloSigma");
        window.__CURRENT_COLS__ = cols;
        theadRow.innerHTML = "";
        tbody.innerHTML = "";

        cols.forEach(c => {
          const th = document.createElement("th");
          th.textContent = c;

          if (!looksLikeResultColumn(c)) {
            th.classList.add("sortable");
          } else {
            th.classList.add("tournament");
          }

          theadRow.appendChild(th);
        });

        const resultCols = new Set(cols.filter(looksLikeResultColumn));

        data.forEach(row => {
          const tr = document.createElement("tr");
          cols.forEach(c => {
            const td = document.createElement("td");
            const val = row[c] ?? "";
            const displayVal = formatMaybe2dp(c, val);
            if (c === "Elo") {
              const pill = document.createElement("span");
              pill.className = `pill elo-pill ${uncertaintyClass(row["EloSigma"])}`;
              pill.textContent = (val === null || val === undefined || val === "") ? "" : String(Math.round(Number(val)));
              td.appendChild(pill);
            } else if (c === "EloSkill") {
              const num = Number(val);
              td.textContent = Number.isFinite(num) ? String(Math.round(num)) : "";
            } else if (c === "EloForm") {
              const num = Number(val);
              if (Number.isFinite(num)) {
                const r = Math.round(num);
                td.textContent = (r > 0 ? "+" : "") + String(r);
              } else {
                td.textContent = "";
              }
            } else {
              td.textContent = displayVal;
            }

            if (resultCols.has(c)) {
              td.classList.add("result-cell");
          td.textContent = displayResultValue(td.textContent);

              const cls = resultClass(val);
              if (cls) td.classList.add(cls);
            }
            tr.appendChild(td);
          });
          tbody.appendChild(tr);
        });

        countEl.textContent = `${data.length} players`;
      }

      function getCellValue(row, idx) {
        const td = row.children[idx];
        return td ? td.textContent.trim() : "";
      }

      function detectType(val) {
        const n = Number(val);
        if (!isNaN(n) && val !== "") return "number";
        return "string";
      }

      function sortBy(colIdx, asc) {
        const rows = Array.from(tbody.querySelectorAll("tr"));
        const type = detectType(getCellValue(rows[0], colIdx));
        rows.sort((a,b) => {
          const va = getCellValue(a,colIdx);
          const vb = getCellValue(b,colIdx);
          if (type === "number") {
            return asc ? (Number(va)-Number(vb)) : (Number(vb)-Number(va));
          }
          return asc ? va.localeCompare(vb) : vb.localeCompare(va);
        });
        rows.forEach(r => tbody.appendChild(r));
      }

      function enableSortAndSearch() {
        let currentSort = { idx: 0, asc: true };

        theadRow.addEventListener("click", (ev) => {
          const th = ev.target.closest("th");
          if (!th) return;
          const idx = Array.from(theadRow.children).indexOf(th);
          if (idx < 0) return;

          const headerText = (th.textContent || "").trim();
          const norm = headerText.toString().replace(/\s+/g," ").trim();
          const isTournament = looksLikeResultColumn(norm);

          if (isTournament) {
            openTournamentDrawFromHeaderText(headerText);
            return;
          }

          // Normal sortable columns
          const asc = (currentSort.idx === idx) ? !currentSort.asc : true;
          currentSort = { idx, asc };

          Array.from(theadRow.children).forEach(h => h.classList.remove("sorted-asc","sorted-desc"));
          th.classList.add(asc ? "sorted-asc" : "sorted-desc");

          sortBy(idx, asc);
        });

        searchBox.addEventListener("input", () => {
          const q = searchBox.value.trim().toUpperCase();
          const rows = Array.from(tbody.querySelectorAll("tr"));
          let shown = 0;
          rows.forEach(tr => {
            const cols = window.__CURRENT_COLS__ || [];
            const idxRank = cols.indexOf("Rank") >= 0 ? cols.indexOf("Rank") : 0;
            const idxInit = cols.indexOf("Initial");
            const idxSur = cols.indexOf("Surname");
            const rank = (tr.children[idxRank]?.textContent || "").toUpperCase();
            const init = (tr.children[idxInit]?.textContent || "").toUpperCase();
            const sur = (tr.children[idxSur]?.textContent || "").toUpperCase();
            const hay = `${rank} ${init} ${sur}`;
            const ok = !q || hay.includes(q);
            tr.style.display = ok ? "" : "none";
            if (ok) shown++;
          });
          countEl.textContent = `${shown} / ${rows.length} players`;
        });

        // Default sort by Rank (column 1 at top)
        sortBy(0, true);
      }

      
      function openMatchModal(title, sub, bodyHtml) {
        const backdrop = document.getElementById("matchModalBackdrop");
        const titleEl = document.getElementById("matchModalTitle");
        const subEl = document.getElementById("matchModalSub");
        const bodyEl = document.getElementById("matchModalBody");
        titleEl.textContent = title;
        subEl.textContent = sub || "";
        bodyEl.innerHTML = bodyHtml || "";
        // Peak Elo toggle (if present)
        const peakBtn = bodyEl.querySelector('[data-peak-toggle="1"]');
        if (peakBtn) {
          peakBtn.addEventListener('click', () => {
            const vEl = bodyEl.querySelector('.eloValue');
            const subEl2 = bodyEl.querySelector('.eloSub');
            if (!vEl) return;
            const cur = vEl.getAttribute('data-current');
            const peak = vEl.getAttribute('data-peak');
            const peakLabel = vEl.getAttribute('data-peaklabel') || '';
            const showing = vEl.getAttribute('data-showing') || 'current';
            if (showing === 'current') {
              vEl.textContent = peak !== null ? peak : (vEl.textContent || '');
              vEl.setAttribute('data-showing','peak');
              peakBtn.textContent = 'Show current';
              if (subEl2) subEl2.textContent = peakLabel ? `Peak at ${peakLabel}` : 'Peak';
            } else {
              vEl.textContent = cur !== null ? cur : (vEl.textContent || '');
              vEl.setAttribute('data-showing','current');
              peakBtn.textContent = 'Show peak';
              if (subEl2) subEl2.textContent = 'Current';
            }
          });
        }
        backdrop.style.display = "flex";
        backdrop.setAttribute("aria-hidden", "false");
      }

      function closeMatchModal() {
        const backdrop = document.getElementById("matchModalBackdrop");
        backdrop.style.display = "none";
        backdrop.setAttribute("aria-hidden", "true");
      }

      function escapeHtml(s) {
        return (s ?? "").toString()
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;");
      }

      
      
      function buildSparkline(values, opts){
        const w = (opts && opts.w) ? opts.w : 200;
        const h = (opts && opts.h) ? opts.h : 44;
        const pad = (opts && opts.pad) ? opts.pad : 4;
        const vals = (Array.isArray(values) ? values : []).map(v => Number(v)).filter(v => Number.isFinite(v));
        if (vals.length < 2){
          return `<svg class="sparkSvg" viewBox="0 0 ${w} ${h}" role="img" aria-label="Form sparkline"></svg>`;
        }
        const minV = Math.min(...vals);
        const maxV = Math.max(...vals);
        const rng = (maxV - minV) || 1;
        const n = vals.length;
        const xStep = (w - 2*pad) / (n - 1);
        const pts = vals.map((v,i)=>{
          const x = pad + i * xStep;
          const y = pad + (maxV - v) * ((h - 2*pad) / rng);
          return `${x.toFixed(2)},${y.toFixed(2)}`;
        }).join(" ");
        // Optional 0-baseline if within range
        let zeroLine = "";
        if (minV < 0 && maxV > 0){
          const y0 = pad + (maxV - 0) * ((h - 2*pad) / rng);
          zeroLine = `<line x1="${pad}" y1="${y0.toFixed(2)}" x2="${(w-pad)}" y2="${y0.toFixed(2)}" stroke="#ddd" stroke-width="1"/>`;
        }
        return `<svg class="sparkSvg" viewBox="0 0 ${w} ${h}" role="img" aria-label="Form sparkline">`
          + zeroLine
          + `<polyline points="${pts}" fill="none" stroke="#333" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>`
          + `</svg>`;
      }


      function normaliseHeader(s){
        return (s ?? "").toString().replace(/\s+/g," ").trim().toUpperCase();
      }

      function openTournamentDrawFromHeaderText(headerText){
        const matchesData = window.__MATCHES_DATA__;
        if (!matchesData || !matchesData.tournaments) return;

        const norm = normaliseHeader(headerText);

        // Prefer direct lookup by header text, then try colToKey mapping if present
        let tourn =
          matchesData.tournaments[norm] ||
          matchesData.tournaments[norm.replace(/\s+/g, "")] ||
          null;

        if (!tourn && matchesData.colToKey) {
          const key = matchesData.colToKey[norm] || matchesData.colToKey[norm.replace(/\s+/g, "")];
          tourn = key ? matchesData.tournaments[key] : null;
        }

        if (!tourn) return;

        const title = `${tourn.tournament}`;
        const subtitle = `Draw`;

        const order = ["L16", "QF", "SF", "F"];
        const byRound = {};
        for (const m of (tourn.matches || [])){
          const r = m.round || "Other";
          (byRound[r] ||= []).push(m);
        }
        let body = "";
        let first = 1;

        const nqTeams = Array.isArray(tourn.nqTeams) ? tourn.nqTeams : [];
        if (nqTeams.length){
          body += `<div class="match-round">Non-Qualifiers</div>`;
          body += `<div class="match">`;
          for (const t of nqTeams){
            if (!t.team) continue;
            if (first === 1){
               first = 0
            } else {
               body += `<br>`;
            }
            body += `<span class="pill">${escapeHtml(t.team)}</span>`;
          }
          body += `</div>`;
        }

          const roundNames = { L16: "Last 16", QF: "Quarter-Finals", SF: "Semi-Finals", F: "Final" };
        for (const r of order){
          const list = byRound[r] || [];
          if (!list.length) continue;
          body += `<div class="match-round">${escapeHtml(roundNames[r])}</div>`;
          for (const m of list){
            const wTeam = m.winnerTeam || "";
            const lTeam = m.loserTeam || "";
            const score = (m.score || "").toString().trim();
            body += `<div class="match">`
              + `<div class="line"><b>${escapeHtml(wTeam)}</b> beat ${escapeHtml(lTeam)}</div>`
              + (score ? `<div class="line">${escapeHtml(score)}</div>` : ``)
              + `</div>`;
          }
        }

        const others = Object.keys(byRound).filter(r => !order.includes(r));
        for (const r of others){
          const list = byRound[r] || [];
          if (!list.length) continue;
          body += `<div class="match-round">${escapeHtml(r)}</div>`;
          for (const m of list){
            const wTeam = m.winnerTeam || "";
            const lTeam = m.loserTeam || "";
            const score = (m.score || "").toString().trim();
            body += `<div class="match">`
              + `<div class="line"><b>${escapeHtml(wTeam)}</b> beat ${escapeHtml(lTeam)}</div>`
              + (score ? `<div class="line">${escapeHtml(score)}</div>` : ``)
              + `</div>`;
          }
        }

        if (!body) body = `<div class="match">No draw data found for this tournament.</div>`;

        // Use the modal that actually exists on the page
        openMatchModal(title, subtitle, body);
      }

      function attachCellClicks(matchesData) {
        const table = document.getElementById("rankings");
        const tbody = table.querySelector("tbody");
        const headers = Array.from(table.querySelectorAll("thead th")).map(th => th.textContent);

        const roundOrder = ["L16", "QF", "SF", "F"];
        const roundNames = { L16: "Last 16", QF: "Quarter-Finals", SF: "Semi-Finals", F: "Final" };

        tbody.addEventListener("click", (ev) => {
          const td = ev.target.closest("td");
          if (!td) return;
          const tr = td.parentElement;
          const tds = Array.from(tr.children);
          const colIdx = tds.indexOf(td);
          const colName = (headers[colIdx] || "").trim();

          if (!/^\d{2}\s+[NKL]$/i.test(colName)) return;

          const result = (td.textContent || "").trim();
          if (!result) return;

          const idxInit = headers.indexOf('Initial');
          const idxSur = headers.indexOf('Surname');
          const initial = (tds[idxInit]?.textContent || "").trim().toUpperCase();
          const surname = (tds[idxSur]?.textContent || "").trim().toUpperCase();
          const playerKey = `${initial}|${surname}`;

          // --- Elo stats (current vs peak) + Form sparkline ---
          const idxElo = headers.indexOf('Elo');
          const idxForm = headers.indexOf('EloForm');
          const currentElo = (idxElo >= 0) ? Number((tds[idxElo]?.textContent || "").trim()) : NaN;
          const currentForm = (idxForm >= 0) ? Number((tds[idxForm]?.textContent || "").trim()) : NaN;

          const series = [];
          const snapsC = Array.isArray(window.__SNAPS_CHRONO) ? window.__SNAPS_CHRONO : [];
          for (const s of snapsC){
            const recs = Array.isArray(s.records) ? s.records : [];
            const r = recs.find(rr => `${(rr.Initial||"").toString().trim().toUpperCase()}|${(rr.Surname||"").toString().trim().toUpperCase()}` === playerKey);
            if (!r) continue;
            const e = Number(r.Elo);
            const f = Number(r.EloForm);
            if (Number.isFinite(e) || Number.isFinite(f)){
              series.push({ label: s.label || s.key, key: s.key, elo: e, form: f });
            }
          }
          // Include the currently rendered row (latest or snapshot) as "Current" point if finite
          if (Number.isFinite(currentElo) || Number.isFinite(currentForm)){
            series.push({ label: 'Current', key: '__current__', elo: currentElo, form: currentForm });
          }

          let peakElo = null;
          let peakLabel = '';
          for (const pt of series){
            if (!Number.isFinite(pt.elo)) continue;
            if (peakElo === null || pt.elo > peakElo){
              peakElo = pt.elo;
              peakLabel = pt.label || pt.key || '';
            }
          }
          const curEloText = Number.isFinite(currentElo) ? Math.round(currentElo).toString() : '';
          const peakEloText = (peakElo !== null && Number.isFinite(peakElo)) ? Math.round(peakElo).toString() : '';
          const sparkVals = series.filter(p => p.key !== '__current__').map(p => p.form).filter(v => Number.isFinite(Number(v)));
          const sparkSvg = buildSparkline(sparkVals, {w:200,h:44,pad:4});
          const idxSkill = headers.indexOf('EloSkill');
          const currentSkill = (idxSkill >= 0) ? Number((tds[idxSkill]?.textContent || "").trim()) : NaN;
          const skillText = Number.isFinite(currentSkill) ? Math.round(currentSkill).toString() : '';
          const formText = Number.isFinite(currentForm) ? ((currentForm>=0?'+':'') + Math.round(currentForm).toString()) : '';

          const eloPanelHtml =
            `<div class="eloPanel">`
            + `<div class="eloRow">`
            + `<div style="display:flex;gap:14px;flex-wrap:wrap;align-items:flex-end;">`
            +   `<div><div class="muted">Elo</div><div><b class="eloValue" data-current="${escapeHtml(curEloText)}" data-peak="${escapeHtml(peakEloText)}" data-peaklabel="${escapeHtml(peakLabel)}" data-showing="current">${escapeHtml(curEloText)}</b> <span class="muted eloSub">Current</span></div></div>`
            +   `<div><div class="muted">Skill</div><div><b>${escapeHtml(skillText)}</b></div></div>`
            +   `<div><div class="muted">Form</div><div><b>${escapeHtml(formText)}</b></div></div>`
            + `</div>`
            + `<button class="peakBtn" type="button" data-peak-toggle="1">Show peak</button>`
            + `</div>`
            + `<div class="sparkWrap"><div class="muted">Form (EloForm)</div>${sparkSvg}</div>`
            + `</div>`;

          const tourn = matchesData?.tournaments?.[colName];
          const tournFull = tourn?.tournament || colName;
        let body = "";
          if (!tourn) {
            body += `<div class="match">No match detail found for ${escapeHtml(colName)}.</div>`;
            openMatchModal(`${initial}. ${surname}`, `${tournFull} (${result})`, body);
            return;
          }

          const inNQ = Array.isArray(tourn.nq) && tourn.nq.includes(playerKey);
          const nqTeams = Array.isArray(tourn.nqTeams) ? tourn.nqTeams : [];
          const hitNQTeam = nqTeams.find(t => Array.isArray(t.players) && t.players.includes(playerKey));
          const nqTeamDisplay = (hitNQTeam && hitNQTeam.team) ? hitNQTeam.team : null;

          const matches = (tourn.matches || []).filter(m => {
            const w = Array.isArray(m.winners) ? m.winners : [];
            const l = Array.isArray(m.losers) ? m.losers : [];
            return w.includes(playerKey) || l.includes(playerKey);
          });

          // Determine the player's team (player + partner) for this tournament
          const prettySurname = (surname || "").slice(0,1) + (surname || "").slice(1).toLowerCase();
          const prettyPlayer = `${initial}.${prettySurname}`;
          let playerTeam = null;
          if (matches.length > 0) {
            const m0 = matches[0];
            const won0 = (m0.winners || []).includes(playerKey);
            playerTeam = won0 ? (m0.winnerTeam || null) : (m0.loserTeam || null);
          }
          if (!playerTeam) playerTeam = prettyPlayer;

          body += `<div class="match"><span class="pill">${escapeHtml(result)}</span><b>${escapeHtml((inNQ && nqTeamDisplay) ? nqTeamDisplay : playerTeam)}</b></div>`;

          if (matches.length === 0 && !inNQ) {
            body += `<div class="match">No match lines found for this player in this tournament.</div>`;
            openMatchModal(`${initial}. ${surname}`, `${tournFull} (${result})`, body);
            return;
          }

          const byRound = {};
          for (const m of matches) {
            const r = m.round || "UNK";
            byRound[r] = byRound[r] || [];
            byRound[r].push(m);
          }

          for (const r of roundOrder) {
            const list = byRound[r];
            if (!list || list.length === 0) continue;
            body += `<div class="match-round">${escapeHtml(roundNames[r])}</div>`;
            for (const m of list) {
              const score = escapeHtml(m.score || "");
              const won = (m.winners || []).includes(playerKey);
              body += `<div class="match">` +
                      `<div class="line"><span class="pill ${won ? "pill-won" : "pill-lost"}">${escapeHtml(won ? "Won" : "Lost")}</span><i>vs</i> ${escapeHtml(won ? (m.loserTeam || "") : (m.winnerTeam || ""))}</div>` +
                      (score ? `<div class="line">${score}</div>` : ``) +
                      `</div>`;
            }
          }

          openMatchModal(`${initial}. ${surname}`, `${tournFull} (${result})`, body);
        });

        document.getElementById("matchModalClose")?.addEventListener("click", closeMatchModal);
        document.getElementById("matchModalBackdrop")?.addEventListener("click", (e) => {
          if (e.target && e.target.id === "matchModalBackdrop") closeMatchModal();
        });
        document.addEventListener("keydown", (e) => {
          if (e.key === "Escape") closeMatchModal();
        });
      }

      (async function main(){
        try {
          const [loaded, matchesData] = await Promise.all([loadData(), loadMatches()]);
          window.__MATCHES_DATA__ = matchesData;

        const snapshotSelect = document.getElementById('snapshotSelect');
        const snapsRaw = (loaded.snapshots && Array.isArray(loaded.snapshots.snapshots)) ? loaded.snapshots.snapshots : [];
        function _parseSnapKey(k){
          const m = /^([0-9]{2})\\s+([NKL])$/i.exec((k||"").trim());
          if (!m) return null;
          const yy = parseInt(m[1],10);
          const year = 2000 + yy;
          const comp = m[2].toUpperCase();
          const order = ({N:0,K:1,L:2})[comp] ?? 99;
          return {year, order};
        }
        const snapsChrono = snapsRaw.slice().sort((a,b)=>{
          const pa=_parseSnapKey(a.key); const pb=_parseSnapKey(b.key);
          if (!pa && !pb) return 0;
          if (!pa) return 1;
          if (!pb) return -1;
          if (pa.year !== pb.year) return pa.year - pb.year;
          return pa.order - pb.order;
        });
        const snapsDesc = snapsChrono.slice().reverse();
        // Keep around for modal sparklines / peak Elo stats
        window.__SNAPS_CHRONO = snapsChrono;
        if (snapshotSelect) {
          snapshotSelect.innerHTML = '';
          const optLatest = document.createElement('option');
          optLatest.value = 'latest';
          optLatest.textContent = 'Latest';
          snapshotSelect.appendChild(optLatest);
          snapsDesc.forEach(s => {
            const opt = document.createElement('option');
            opt.value = s.key;
            opt.textContent = s.label;
            snapshotSelect.appendChild(opt);
          });
          snapshotSelect.value = 'latest';
          snapshotSelect.addEventListener('change', () => {
            const v = snapshotSelect.value;
            if (v === 'latest') {
              render(loaded.latest);
              statusEl.textContent = 'Showing latest';
            } else {
              const snap = snapsChrono.find(x => x.key === v);
              if (snap && Array.isArray(snap.records)) {
                render(snap.records);
                statusEl.textContent = `As of ${snap.label}`;
              }
            }
            // reset search + sort
            searchBox.value = '';
            sortBy(0, true);
          });
        }

          render(loaded.latest);
          enableSortAndSearch();
          attachCellClicks(matchesData);
          statusEl.textContent = "Showing latest";
        } catch (e) {
          console.error(e);
          statusEl.textContent = (e && e.message) ? e.message : "Failed to load rankings data.";
        }
      })();
    })();
  

// ------------------------
// Full screen toggle (mobile landscape helper)
// ------------------------
const fsBtn = document.getElementById('fsBtn');
const helpBtn = document.getElementById('helpBtn');
const tableWrap = document.getElementById('tableWrap');

function setFullscreenMode(on){
  document.body.classList.toggle('fullscreen-mode', !!on);
  fsBtn.textContent = on ? '√ó' : '‚õ∂';
  fsBtn.title = on ? 'Exit full screen' : 'Full screen';
  fsBtn.setAttribute('aria-label', fsBtn.title);
}

async function toggleFullscreen(){
  const isFs = !!document.fullscreenElement;
  if (!isFs) {
    // Prefer the Fullscreen API when available, but also apply CSS fallback.
    setFullscreenMode(true);
    try{
      // IMPORTANT: request fullscreen on the document element so modal dialogs (which live under <body>)
      // remain visible and usable in fullscreen mode.
      if (document.documentElement.requestFullscreen) await document.documentElement.requestFullscreen();
    }catch(e){
      // Ignore; CSS fullscreen-mode still helps on mobile.
    }
  } else {
    try{
      await document.exitFullscreen();
    }catch(e){
      // ignore
    }
    setFullscreenMode(false);
  }
}

if (fsBtn){
  fsBtn.addEventListener('click', toggleFullscreen);
}

// Keep CSS state in sync if user exits fullscreen via OS gesture.
document.addEventListener('fullscreenchange', () => {
  const on = !!document.fullscreenElement;
  setFullscreenMode(on);
});

// ------------------------
// Help modal (Rank / Elo tabs)
// ------------------------
// Note: the Help modal markup sits after this script tag in the HTML.
// So we must wire up its elements after the DOM is fully parsed.
function wireHelpModal(){
  const helpBackdrop = document.getElementById('helpModalBackdrop');
  const helpClose = document.getElementById('helpModalClose');
  const tabRank = document.getElementById('tabRank');
  const tabElo = document.getElementById('tabElo');
  const panelRank = document.getElementById('panelRank');
  const panelElo = document.getElementById('panelElo');

  function switchHelpTab(which){
    const isRank = (which === 'rank');
    if(tabRank) tabRank.setAttribute('aria-selected', isRank ? 'true' : 'false');
    if(tabElo) tabElo.setAttribute('aria-selected', isRank ? 'false' : 'true');
    if(panelRank) panelRank.classList.toggle('active', isRank);
    if(panelElo) panelElo.classList.toggle('active', !isRank);
  }

  function openHelp(){
    if(!helpBackdrop) return;
    helpBackdrop.style.display='flex';
    helpBackdrop.setAttribute('aria-hidden','false');
    switchHelpTab('rank');
  }
  function closeHelp(){
    if(!helpBackdrop) return;
    helpBackdrop.style.display='none';
    helpBackdrop.setAttribute('aria-hidden','true');
  }

  if(helpBtn) helpBtn.addEventListener('click', openHelp);
  if(helpClose) helpClose.addEventListener('click', closeHelp);
  if(helpBackdrop) helpBackdrop.addEventListener('click', (e)=>{ if(e.target===helpBackdrop) closeHelp(); });
  if(tabRank) tabRank.addEventListener('click', ()=>switchHelpTab('rank'));
  if(tabElo) tabElo.addEventListener('click', ()=>switchHelpTab('elo'));

  // ESC closes help (and exits fullscreen CSS mode if open)
  document.addEventListener('keydown', (e)=>{
    if(e.key==='Escape'){
      closeHelp();
      if(!document.fullscreenElement){
        setFullscreenMode(false);
      }
    }
  });
}

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', wireHelpModal);
} else {
  wireHelpModal();
}

</script>

  <div class="modal-backdrop" id="matchModalBackdrop" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal" id="matchModal">
      <header>
        <div>
          <h2 id="matchModalTitle">Match details</h2>
          <div class="small" id="matchModalSub"></div>
        </div>
        <button class="close" id="matchModalClose" type="button">Close</button>
      </header>
      <div class="content" id="matchModalBody"></div>
    </div>
  </div>

  <!-- Help modal -->
  <div class="modal-backdrop" id="helpModalBackdrop" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal" id="helpModal">
      <header>
        <div>
          <h2 id="helpModalTitle">Help</h2>
          <div class="small" id="helpModalSub">How rankings and Elo are calculated</div>
        </div>
        <button class="close" id="helpModalClose" type="button">Close</button>
      </header>

      <div class="tabs" role="tablist" aria-label="Help tabs">
        <button class="tabbtn" id="tabRank" role="tab" aria-selected="true" aria-controls="panelRank" type="button">Rank</button>
        <button class="tabbtn" id="tabElo" role="tab" aria-selected="false" aria-controls="panelElo" type="button">Elo</button>
      </div>

      <div class="tabpanel active" id="panelRank" role="tabpanel" aria-labelledby="tabRank">
  <h3>Overview</h3>
  <p>The official ranking is computed over a rolling <b>7-year window</b>. Each tournament result is first mapped to two point values:</p>
  <ul>
    <li><b>RPA points</b> (reward for progress)</li>
    <li><b>POSS points</b> (possible / participation weighting)</li>
  </ul>
  <p>These are then time-decayed, totalled, and ratioed to form the percentage score:
    <b>PC = 100 √ó RPA / POSS</b>.</p>

  <h3>Step 1 ‚Äî Map each finish to points (tournament-specific)</h3>
  <p>Finish codes are: <b>W</b>, <b>F</b>, <b>SF</b>, <b>QF</b>, <b>L16</b> (where applicable), <b>NQ</b>, <b>DNS</b>, <b>NA</b>.</p>
  <ul>
    <li><b>Kinnaird</b><br/>
      RPA: W 15, F 13.5, SF 9.6, QF 5.6, L16 2, (NQ/DNS/NA ‚Üí 0)<br/>
      POSS: W 15, F 15, SF 12, QF 8, L16 4, NQ 2, DNS 1, NA 0
    </li>
    <li><b>Northern</b> and <b>London</b><br/>
      RPA: W 10, F 8, SF 5.2, QF 3, (NQ/DNS/NA ‚Üí 0)<br/>
      POSS: W 10, F 10, SF 8, QF 6, NQ 2, DNS 1, NA 0
    </li>
  </ul>
  <p class="muted">These tables compensate for competition structure (e.g. Kinnaird has an L16 stage in the model). There is no additional ‚Äúprestige multiplier‚Äù by tournament name.</p>

  <h3>Step 2 ‚Äî Apply time decay (7-year window)</h3>
  <p>Each tournament result is aged as <code>age = LastHeldYear ‚àí ResultYear</code> and given a decay weight:</p>
  <p><code>[1.00, 0.85, 0.70, 0.55, 0.40, 0.25, 0.10]</code> for ages 0‚Äì6; ages ‚â•7 get weight 0.</p>

  <h3>Step 3 ‚Äî Total and ratio</h3>
  <ul>
    <li><code>RPA = Œ£(decay √ó rpa_points)</code></li>
    <li><code>POSS = Œ£(decay √ó poss_points)</code></li>
    <li><code>PC = 100 √ó RPA / POSS</code></li>
  </ul>

  <h3>Step 4 ‚Äî Participation / inactivity penalty (PC2)</h3>
  <p>A large penalty is applied if either:</p>
  <ul>
    <li>the player has played <b>&lt; 3 tournaments</b> in-window (excluding DNS/NA), or</li>
    <li>the player has missed <b>3+ consecutive tournaments</b> since first appearing (DNS streak)</li>
  </ul>
  <p>In those cases: <code>PC2 = PC / 1000</code>. Otherwise: <code>PC2 = PC</code>.</p>

  <h3>Sorting / tie-breaks</h3>
  <p>Final ordering is by <b>PC2</b> (desc), then <b>POSS</b> (desc), with stable tie-breaking for a deterministic list.</p>
</div>

<div class="tabpanel" id="panelElo" role="tabpanel" aria-labelledby="tabElo">
  <h3>Overview</h3>
  <p>Elo is an experimental rating designed to reflect <b>quality of opposition</b> and <b>recent form</b>, while staying stable with low tournament volume.</p>
  <p>Each player has two components:</p>
  <ul>
    <li><b>EloSkill</b> ‚Äî long-run ability (moves slowly)</li>
    <li><b>EloForm</b> ‚Äî current momentum (moves quickly and decays toward 0)</li>
  </ul>
  <p><b>Elo = EloSkill + EloForm</b>.</p>

  <h3>Core parameters</h3>
  <ul>
    <li>Baseline (Œº): <code>1500</code></li>
    <li>Base K: <code>12</code></li>
    <li>Uncertainty (œÉ): new <code>350</code>, floor <code>120</code>, cap <code>400</code></li>
    <li>Skill/Form split: <code>ELO_SKILL_SHARE = 0.15</code> (15% of each update to Skill; 85% to Form)</li>
    <li>Form half-life: <code>1.5 years</code> (decays between tournaments)</li>
    <li>Tournament K multiplier: <b>Kinnaird</b> uses <code>√ó 1.12</code> (Northern/London: √ó 1.00)</li>
  </ul>

  <h3>Form decay (recency without mean reversion)</h3>
  <p>Between tournaments, only Form decays:</p>
  <p><code>Form ‚Üê Form √ó 2^(‚àíŒît / 1.5)</code>, where Œît is measured in ‚Äútournament-time‚Äù
     (Northern / Kinnaird / London are treated as ~‚Öì-year steps).</p>
  <p class="muted">Skill does not mean-revert; older dominance persists via Skill. What fades is the extra ‚Äúedge‚Äù in Form unless reinforced.</p>

  <h3>Uncertainty and effective K</h3>
  <ul>
    <li>Inactivity: œÉ increases by <code>+50</code> per inactive year (up to 400).</li>
    <li>After each match/bonus update: <code>œÉ ‚Üê max(120, 0.85 √ó œÉ)</code>.</li>
    <li>Effective K: <code>K_eff = 12 √ó (1 + œÉ/300)</code>.</li>
  </ul>
  <p class="muted">Rationale: long-absent players are treated as more uncertain, so results move them more, but œÉ quickly tightens again as they play.</p>

  <h3>Round weighting</h3>
  <p>Match updates are weighted by round:</p>
  <ul>
    <li>L16: 1.00</li>
    <li>QF: 1.06</li>
    <li>SF: 1.12</li>
    <li>F: 1.18</li>
  </ul>

  <h3>Walkovers / retirements</h3>
  <ul>
    <li>Walkover (<code>w/o</code>, <code>wo</code>, ‚Äúwalkover‚Äù): coefficient <code>0.25</code></li>
    <li>Retirements (<code>ret</code>): coefficient scales from ~<code>0.25</code> (early) up to <code>1.0</code> (near-win), based on the scoreline; defaults to 0.50 if unclear.</li>
  </ul>

  <h3>Passenger effect split (doubles)</h3>
  <p>The match produces a <b>team</b> Elo delta, then we split it between partners based on their current rating gap:</p>
  <ul>
    <li><b>Near-equal partners</b>: split is ~<b>50/50</b>.</li>
    <li><b>Big gaps</b>: split smoothly approaches up to <b>70/30</b> (configurable).</li>
    <li><b>Direction</b>: the <b>stronger partner gains more</b> for wins and <b>loses less</b> for losses.</li>
  </ul>
  <p class="muted">Parameters: max bias = <code>PASSENGER_MAX_BIAS=0.20</code> (so 50/50 ‚Üí 70/30), reaching max bias at a rating gap of <code>PASSENGER_DIFF_SCALE=200</code>. Rationale: we don‚Äôt want good players penalised for partnering weaker players, but we still want to avoid over-crediting a weak ‚Äúpassenger‚Äù when the gap is large.</p>

  <h3>Tournament bonuses (applied before matches)</h3>
  <ul>
	    <li><b>Entry bonus</b>: every entrant gets a pseudo-win vs a <code>1400</code>-rated opponent (using <code>K_eff</code>, with the tournament K multiplier applied).</li>
	    <li><b>Qualification bonus</b>: players who reach the main draw (non-NQ) get a pseudo-win vs the <b>average Elo of that tournament‚Äôs non-qualifiers</b> (also with the tournament K multiplier applied).</li>
  </ul>
  <p class="muted">Rationale: entering majors is informative; qualifying should matter, and the bonus scales with how strong the NQ pool is.</p>

  <h3>What Elo is optimising for</h3>
  <ul>
    <li>Strong recent wins (especially late rounds) can move a player quickly via Form.</li>
    <li>Repeated historical dominance accumulates in Skill.</li>
    <li>Ratings reflect opposition quality, not just finishing position.</li>
  </ul>
</div>
    </div>
  </div>

</body>
</html>
